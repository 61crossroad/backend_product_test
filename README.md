# backend_product_test  
### JDK 1.8 | SpringBoot 2.3.4 | JdbcTemplate | H2 Database  
#### n + 1 쿼리를 해결하기 위해 join된 각 Result Set을 LinkedHashMap에 매핑했다.  
##### 쿼리 결과 중 중복된 키 컬럼 처리를 위해 Map을 사용했으며, 쿼리 순서대로 List에 넣기 위해 put 순서가 유지되는 LinkedHashMap을 사용했다.  
상품 목록 : 신발1, 신발2, 가방1, 티셔츠1, 티셔츠2, 티셔츠3, 바지1, 모자1, 반지 ...  
상품 구성 : 단품, 티셔츠 1+1, 바지+모자, 가방+신발(옵션) ...  
  
상품과 상품 구성이 DB에 입력되어 있을때 가능한 모든 상품 구성을 select 한다.  
  
이 문제는 결국 상품 구성에 맞춰서 모든 상품 조합의 경우의 수를 찾는 것이다.  
경우의 수라면 바로 DFS나 BFS를 떠올릴 수 있겠는데, 실제로 서비스 중인 백엔드 환경이라면 스택 오버플로우 위험이 있고 함수 콜 때문에 느린 DFS보다 BFS가 나을 것으로 생각했다.  
  
BFS를 구현한다면 우선 상태 공간 트리를 정의해야 한다.  
트리의 깊이는 해당 상품 구성의 각 요소이다.  
예를 들어서 상품 구성이 '신발 + 가방 + 티셔츠'라면  
깊이 0 : 신발  
깊이 1 : 가방  
깊이 2 : 티셔츠  
가 된다.
그리고 각 깊이에 할당될 수 있는 상품들을 노드로 등록한다.  
  
위의 상품 구성과 상품 목록을 조합하면  
(루트) - (신발1) - (가방1) - (티셔츠1, 티셔츠2, 티셔츠3)  
(루트) - (신발2) - (가방1) - (티셔츠1, 티셔츠2, 티셔츠3)  
와 같은 2가지 부분 트리가 루트부터 만들어진다.  
  
그렇다면 노드의 정의를 n(i, j)라고 했을 때,  
i = 노드의 깊이 즉, i번째 상품 구성  
j = i에 해당하는 상품 j  
로 트리를 만들 수 있다.
